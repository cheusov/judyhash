<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<TITLE></TITLE>
<META NAME="generator" CONTENT="HTML::TextToHTML v2.44">
</HEAD>
<BODY>
<H1><A NAME="section_1">OVERVIEW</A></H1>

<P>The judyhash project <A HREF="http://judyhash.sourceforge.net">http://judyhash.sourceforge.net</A>
provides several hash map (and set)<BR>
implementations based on Judy array (<A HREF="http://judy.sourceforge.net">http://judy.sourceforge.net</A>).
All these maps and sets are implemented using C++ programming language
and have an API similar to that of SGI STL's hash_map
(or std::unordered_map) and STL classes.

<H1><A NAME="section_2">FEATURES</A></H1>

<P>judyhash project provides the following classes

<OL>
  <LI>judy_set_l    A set similar to std::set
  <LI>judy_set_m    Similar to judy_set_l but uses a bit different algorithm
  <LI>judy_set_cell A set of of keys of integer type or pointer types
<P>                   (sizeof which is less of equal than JudyL's Word_t)
  <LI>judy_map_l    Associative array similar to std::map
<P>                   and SGI STL's std::hash_map
  <LI>judy_map_m    Similar to judy_map_l but with a bit different algorithm
  <LI>judy_map_cell Associative array. Both key and data are of integer or
<P>                   of pointer type.
</OL>
<H1><A NAME="section_3">INCLUDES</A></H1>

<OL>
  <LI>judy_map.h           All classes for associative arrays
  <OL>
    <LI>judy_map_kdcell.h    judy_map_kdcell class only
    <LI>judy_map_l.h         judy_map_l class only
    <LI>judy_map_m.h         judy_map_m class only
  </OL>
  <LI>judy_set.h           All classes for sets
  <OL>
    <LI>judy_set_cell.h      judy_set_cell class only
    <LI>judy_set_l.h         judy_set_l class only
    <LI>judy_set_m.h         judy_set_m class only
  </OL>
</OL>
<H1><A NAME="section_4">ALGORITHMS AND COMPLEXITY</A></H1>

<P>In traditional hash tables linear array is used for mapping
a hash value to an element, most often by making modulo operation
where divisor is the hash table size or something similar.
Traditional hash tables has two main problems:
1) hash table resizing, i.e. increasing it when there are too many elements
<P>   and decreasing when only a few has table cells are actually used;
2) collisions.

<P>Instead of linear array, judyhash classes
use a JudyL set of functions from Judy library (See url below).
JudyL implements a high-performance map from an integer type to a pointer type
(actually a map from Word_t to Word_t which is capable
for storing both int and void *).<BR>
Thus we have:<BR>
1) some overhead for mapping a hash value to an element
<P>   (JudyL is slower than 'pointer[index]');
2) hash value in a range [0..2^32-1] (the default on 32/64 platforms) and,
<P>   as a result, (<EM>very rare</EM>) collisions;
3) dynamic resizing of hash table, i.e. memory is allocated (and freed)
<P>   as soon as it is needed (or unneeded anymore).

<P>In case of collisions judy_map_{l,m} and judy_set_{l,m} classes use
chaining technique to resolve the collision, i.e. external storage is
used for storing conflicting elements.  judy_{set,map}_l classes use
list, while judy_{set,map}_m use map (or set),
this is why judy_{set,map}_m classes require Less predicate in
addition to Equal.

<P>judy_map_kdcell is actually a C++ STL-like wrapper for JudyL functions
and therefore both key and data should be of integer or pointer type.

<P>judy_set_cell is actually a C++ STL-like wrapper for Judy1 functions
and therefore the type of key should be integer or pointer.

<P><STRONG>TTX: ;-)</STRONG>

<PRE>
           |         |          |                           |
           | SGI's   |judy_map_l|judy_map_m                 |judy_map_kdcell
           | hash_map|judy_set_l|judy_set_m                 |judy_set_cell
---------------------------------------------------------------------------
insert()   | O(N)    | O(N)     |O(log(N))                  | O(1)
find()     |         |          |                           |
erase()    |         |          |                           |
           |         |          |                           |
worst      |         |          |                           |
case       |         |          |                           |
---------------------------------------------------------------------------
insert()   | O(1)    | O(1)     | O(1)                      | O(1)
find()     |         |          |                           |
erase()    |         |          |                           |
           |         |          |                           |
average    |         |          |                           |
case       |         |          |                           |
---------------------------------------------------------------------------
key type   | any     | any      | any                       |integer
           |         |          |                           |or
           |         |          |                           |pointer
---------------------------------------------------------------------------
data type  | any     | any      | any                       |integer
           |         |          |                           |or
           |         |          |                           |pointer
---------------------------------------------------------------------------
erase()    | no      | yes      | yes                       | yes
frees      |         |          |                           |
memory     |         |          |                           |
---------------------------------------------------------------------------
smooth     | no      | yes      | yes                       | yes
resizing   |         |          |                           |
---------------------------------------------------------------------------
limitations| -       | 0==1&amp;(maxint_t)m_alloc.allocate(1)   |
</PRE>
<H1><A NAME="section_5">INSTALL</A></H1>

<P>NOTE! BSD make program is required!!!<BR>
Under Linux you can probably find it under the name 'pmake'.

<P>There is nothing to be built for installing
this library, only C++ header files are installed by

<P>'make install'

<P>Of course, you can install all header files manually,
they are in src_lib directory.

<P>You can also test judyhash library.<BR>
For this, edit manually Makefile.config file for your preferences
and then run

<P>'make test'

<P>Note that some libraries should be properly installed
(and configured in Makefile.config) for this to work.

<H1><A NAME="section_6">BENCHMARKING</A></H1>

<P>Benchmarks for several platforms are available
here <A HREF="http://judyhash.sourceforge.net/benchmark">http://judyhash.sourceforge.net/benchmark</A>

<P>Edit Makefile.bench, read Makefile carefully and then run the following

<P>'make bench'

<H1><A NAME="section_7">CONCLUSION</A></H1>
<P>An associative array of type (integer -&gt; pointer) is one of the most important
data structure that ever exists ;-)
</BODY>
</HTML>
