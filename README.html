<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<TITLE></TITLE>
<META NAME="generator" CONTENT="txt2html v1.28">
</HEAD>
<BODY>
<P>
<STRONG>OVERVIEW</STRONG>
<HR>

<P>
The judyhash project <A HREF="http://sourceforge/projects/judyhash">http://sourceforge/projects/judyhash</A>
provides several hash map (and set)<BR>
implementations based on Judy array (<A HREF="http://sourceforge.net/projects/judy">http://sourceforge.net/projects/judy</A>).
All these maps and sets are implemented using C++ programming language
and have an API similar to that of SGI STL's hash_map
(or std::unordered_map) and STL classes.

<P>
<STRONG>FEATURES</STRONG>
<HR>

<P>
judyhash project provides the following classes

<OL>
  <LI>judy_set_l    - A set similar to std::set
  <LI>judy_set_m    - Similar to judy_set_l but uses a bit different algorithm
  <LI>judy_set_cell - A set of of keys of integer type or pointer types
                      (sizeof which is less of equal than JudyL's Word_t)
  <LI>judy_map_l    - Associative array similar to std::map
                      and SGI STL's std::hash_map
  <LI>judy_map_m    - Similar to judy_map_l but with a bit different algorithm
  <LI>judy_map_cell - Associative array. Both key and data are of integer or
                      of pointer type.

</OL>
<P>
<STRONG>INCLUDES</STRONG>
<HR>

<OL>
  <LI>judy_map.h           All classes for associative arrays
  <OL>
    <LI>judy_map_kdcell.h    judy_map_kdcell class only
    <LI>judy_map_l.h         judy_map_l class only
    <LI>judy_map_m.h         judy_map_m class only
  </OL>
  <LI>judy_set.h           All classes for sets
  <OL>
    <LI>judy_set_cell.h      judy_set_cell class only
    <LI>judy_set_l.h         judy_set_l class only
    <LI>judy_set_m.h         judy_set_m class only

  </OL>
</OL>
<P>
<STRONG>ALGORITHMS AND COMPLEXITY</STRONG>
<HR>

<P>
In traditional hash tables linear array is used for mapping
a hash value to an element, most often by making modulo operation
where divisor is the hash table size or something similar.
Traditional hash tables has two main problems:
1) hash table resizing, i.e. increasing it when there are too many elements
<P>
   and decreasing when only a few has table cells are actually used;
2) collisions.

<P>
Instead of linear array, judyhash classes
use a JudyL set of functions from Judy library (See url below).
JudyL implements a high-performance map from an integer type to a pointer type
(actually a map from Word_t to Word_t which is capable
for storing both int and void *).<BR>
Thus we have:<BR>
1) some overhead for mapping a hash value to an element
<P>
   (JudyL is slower than 'pointer[index]');
2) hash value in a range [0..2^32-1] (the default on 32/64 platforms) and,
<P>
   as a result, (<EM>very rare</EM>) collisions;
3) dynamic resizing of hash table, i.e. memory is allocated (and freed)
<P>
   as soon as it is needed (or unneeded anymore).

<P>
In case of collisions judy_map_{l,m} and judy_set_{l,m} classes use
chaining technique to resolve the collision, i.e. external storage is
used for storing conflicting elements.  judy_{set,map}_l classes use
list, while judy_{set,map}_m use map (or set),
this is why judy_{set,map}_m classes require Less predicate in
addition to Equal.

<P>
judy_map_kdcell is actually a C++ STL-like wrapper for JudyL functions
and therefore both key and data should be of integer or pointer type.

<P>
judy_set_cell is actually a C++ STL-like wrapper for Judy1 functions
and therefore the type of key should be integer or pointer.

<P>
<STRONG>TTX: ;-)</STRONG>

<HR>
<PRE>
           |         |          |                           |
           | SGI's   |judy_map_l|judy_map_m                 |judy_map_kdcell
           | hash_map|judy_set_l|judy_set_m                 |judy_set_cell
---------------------------------------------------------------------------
insert()   | O(N)    | O(N)     |O(log(N))                  | O(1)
find()     |         |          |                           |
erase()    |         |          |                           |
           |         |          |                           |
worst      |         |          |                           |
case       |         |          |                           |
---------------------------------------------------------------------------
insert()   | O(1)    | O(1)     | O(1)                      | O(1)
find()     |         |          |                           |
erase()    |         |          |                           |
           |         |          |                           |
average    |         |          |                           |
case       |         |          |                           |
---------------------------------------------------------------------------
key type   | any     | any      | any                       |integer
           |         |          |                           |or
           |         |          |                           |pointer
---------------------------------------------------------------------------
data type  | any     | any      | any                       |integer
           |         |          |                           |or
           |         |          |                           |pointer
---------------------------------------------------------------------------
erase()    | no      | yes      | yes                       | yes
frees      |         |          |                           |
memory     |         |          |                           |
---------------------------------------------------------------------------
smooth     | no      | yes      | yes                       | yes
resizing   |         |          |                           |
---------------------------------------------------------------------------
limitations| -       | 0==1&amp;(maxint_t)m_alloc.allocate(1)   |
</PRE>
<HR>

<P>
<STRONG>INSTALL</STRONG>
<HR>

<P>
NOTE! BSD make program is required!!!<BR>
Under Linux you can probably find it under name 'pmake'.

<P>
There is nothing to be built for installing
this library, only C++ headers files are installed by

<P>
'make install'

<P>
You can also test judyhash library.<BR>
Edit manually Makefile.config file for your preferences
for this and then run

<P>
'make test'

<P>
Note that some libraries should be properly installed
(and configured in Makefile.config) for this to work.

<P>
<STRONG>BENCHMARKING</STRONG>
<HR>

<P>
Edit Makefile.bench, read Makefile carefully and then run the following

<P>
'make bench'

<P>
<STRONG>CONCLUSION</STRONG>
<HR>
An associative array of type (integer -&gt; pointer) is one of the most important
data structure that ever exists ;-)

</BODY>
</HTML>
