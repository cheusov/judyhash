The judyarray project provides several hash map implementations based
on digital trees which in turn are implemented by judy project
(http://sourceforge.net/projects/judy). All they are implemented using
C++ language and have an API similar to that of SGI STL's hash_map class.

Features
================
judyarray project provides the following classes

judy_set_l    - A set similar to std::set
judy_set_m    - Similar to judy_set_l but uses a bit different algorithm
judy_set_cell - A set of of keys of integer type or pointer types
                (sizeof which is less of equal than JudyL's Word_t)
judy_map_l    - Associative array similar to std::map
                and SGI STL's std::hash_map
judy_map_m    - Similar to judy_map_l but with a bit different algorithm
judy_map_cell - Associative array. Both key and data are of integer or
                of pointer type.

Includes
================
judy_map.h           - All classes for associative arrays
  judy_map_kdcell.h  - judy_map_kdcell class only
  judy_map_l.h       - judy_map_l class only
  judy_map_m.h       - judy_map_m class only
judy_set.h           - All classes for sets
  judy_set_cell.h    - judy_set_cell class only
  judy_set_l.h       - judy_set_l class only
  judy_set_m.h       - judy_set_m class only

Algorithms and complexity
=========================
In traditional hash tables linear continuous array is used for mapping
a hash value to an element, most often by making modulo operation
where divisor is the has table size.
Traditional hash tables has two main problems:
1) Modulo of hash value increases a probability of a collision;
1) hash table resizing, i.e. increasing it when there are too many elements
   and decreasing when only a few elements are in it.

Instead of linear array, judyarray classes
use a JudyL set of functions from Judy library (See url below).
JudyL implements a high-performance map from an integer type to a pointer type
(actually a map from Word_t to Word_t which is capable
for storing both int and void *).
Thus we have:
1) Some overhead for mapping itself (JudyL is slower than 'pointer[index]');
2) Hash value in a range [0..2^32-1] and, as a result, very rare collisions;
3) Dynamic resizing of hash table, i.e. memory is allocated (and freed)
   as soon as it is needed (or unneeded anymore).

In case of collisions judy_map_{l,m} and judy_set_{l,m} classes
use chaining technique to resolve the collision. judy_{set,map}_l
classes use list for storing elements, while judy_{set,map}_m
use map (or set), this is why judy_{set,map}_m classes require
Less predicate in addition to Equal.

API
================

CONFIGURING
================
Edit manually Makefile.config file for you preferences

MAKING
================
After editing Makefile.config you may want to test the library.
For this run the following

'make test'

INSTALL
================
There is nothing to be built for installing
this library, only C++ headers files are installed by

'make install'

command
