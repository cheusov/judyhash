OVERVIEW
================

The libjudyhash project provides several hash map (and set)
implementations based on Judy array (http://sourceforge.net/projects/judy).
All these maps and sets are implemented using C++ language
and have an API similar to that of SGI STL's hash_map
(or std::unordered_map) and STL classes.

libjudyhash sources are available at
http://mova.org/~cheusov/pub/libjudyhash/

FEATURES
================

libjudyhash project provides the following classes

judy_set_l    - A set similar to std::set
judy_set_m    - Similar to judy_set_l but uses a bit different algorithm
judy_set_cell - A set of of keys of integer type or pointer types
                (sizeof which is less of equal than JudyL's Word_t)
judy_map_l    - Associative array similar to std::map
                and SGI STL's std::hash_map
judy_map_m    - Similar to judy_map_l but with a bit different algorithm
judy_map_cell - Associative array. Both key and data are of integer or
                of pointer type.

INCLUDES
================

judy_map.h           - All classes for associative arrays
  judy_map_kdcell.h  - judy_map_kdcell class only
  judy_map_l.h       - judy_map_l class only
  judy_map_m.h       - judy_map_m class only
judy_set.h           - All classes for sets
  judy_set_cell.h    - judy_set_cell class only
  judy_set_l.h       - judy_set_l class only
  judy_set_m.h       - judy_set_m class only

ALGORITHMS AND COMPLEXITY
=========================

In traditional hash tables linear array is used for mapping
a hash value to an element, most often by making modulo operation
where divisor is the hash table size or something similar.
Traditional hash tables has two main problems:
1) hash table resizing, i.e. increasing it when there are too many elements
   and decreasing when only a few has table cells are actually used;
2) collisions.

Instead of linear array, libjudyhash classes
use a JudyL set of functions from Judy library (See url below).
JudyL implements a high-performance map from an integer type to a pointer type
(actually a map from Word_t to Word_t which is capable
for storing both int and void *).
Thus we have:
1) some overhead for mapping a hash value to an element
   (JudyL is slower than 'pointer[index]');
2) hash value in a range [0..2^32-1] (the default on 32/64 platforms) and,
   as a result, (*very rare*) collisions;
3) dynamic resizing of hash table, i.e. memory is allocated (and freed)
   as soon as it is needed (or unneeded anymore).

In case of collisions judy_map_{l,m} and judy_set_{l,m} classes use
chaining technique to resolve the collision, i.e. external storage is
used for storing conflicting elements.  judy_{set,map}_l classes use
list, while judy_{set,map}_m use map (or set),
this is why judy_{set,map}_m classes require Less predicate in
addition to Equal.

judy_map_kdcell is actually a C++ STL-like wrapper for JudyL functions
and therefore both key and data should be of integer or pointer type.

judy_set_cell is actually a C++ STL-like wrapper for Judy1 functions
and therefore the type of key should be integer or pointer.

TTX: ;-)

---------------------------------------------------------------------------
           |         |          |                           |
           | SGI's   |judy_map_l|judy_map_m                 |judy_map_kdcell
           | hash_map|judy_set_l|judy_set_m                 |judy_set_cell
---------------------------------------------------------------------------
insert()   | O(N)    | O(N)     |O(log(N))                  | O(1)
find()     |         |          |                           |
erase()    |         |          |                           |
           |         |          |                           |
worst      |         |          |                           |
case       |         |          |                           |
---------------------------------------------------------------------------
insert()   | O(1)    | O(1)     | O(1)                      | O(1)
find()     |         |          |                           |
erase()    |         |          |                           |
           |         |          |                           |
average    |         |          |                           |
case       |         |          |                           |
---------------------------------------------------------------------------
key type   | any     | any      | any                       |integer
           |         |          |                           |or
           |         |          |                           |pointer
---------------------------------------------------------------------------
data type  | any     | any      | any                       |integer
           |         |          |                           |or
           |         |          |                           |pointer
---------------------------------------------------------------------------
erase()    | no      | yes      | yes                       | yes
frees      |         |          |                           |
memory     |         |          |                           |
---------------------------------------------------------------------------
smooth     | no      | yes      | yes                       | yes
resizing   |         |          |                           |
---------------------------------------------------------------------------
limitations| -       | 0==1&(maxint_t)m_alloc.allocate(1)   |
---------------------------------------------------------------------------

INSTALL
================

NOTE! BSD make programs is required!!!
Under Linux you can probably find it under pmake name.

Edit manually Makefile.config file for your preferences

After editing Makefile.config you may want to test the library.
Run the following for this

'make test'

Note that some libraries should be properly installed
(and configured in Makefile.config) for this to work.

There is nothing to be built for installing
this library, only C++ headers files are installed by

'make install'

BENCHMARKING
================

Edit Makefile.bench and then run the following

'make bench'

CONCLUSION
================
An associative array of type (integer -> pointer) is one of the most important
data structure that ever exists ;-)
