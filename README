OVERVIEW
================

The judyarray project provides several hash map implementations based
on digital trees which in turn are implemented by Judy project
(http://sourceforge.net/projects/judy). All they are implemented using
C++ language and have an API similar to that of SGI STL's hash_map and
STL classes.

FEATURES
================

judyarray project provides the following classes

judy_set_l    - A set similar to std::set
judy_set_m    - Similar to judy_set_l but uses a bit different algorithm
judy_set_cell - A set of of keys of integer type or pointer types
                (sizeof which is less of equal than JudyL's Word_t)
judy_map_l    - Associative array similar to std::map
                and SGI STL's std::hash_map
judy_map_m    - Similar to judy_map_l but with a bit different algorithm
judy_map_cell - Associative array. Both key and data are of integer or
                of pointer type.

INCLUDES
================

judy_map.h           - All classes for associative arrays
  judy_map_kdcell.h  - judy_map_kdcell class only
  judy_map_l.h       - judy_map_l class only
  judy_map_m.h       - judy_map_m class only
judy_set.h           - All classes for sets
  judy_set_cell.h    - judy_set_cell class only
  judy_set_l.h       - judy_set_l class only
  judy_set_m.h       - judy_set_m class only

ALGORITHMS AND COMPLEXITY
=========================

In traditional hash tables linear array is used for mapping
a hash value to an element, most often by making modulo operation
where divisor is the hash table size.
Traditional hash tables has two main problems:
1) hash table resizing, i.e. increasing it when there are too many elements
   and decreasing when only a few elements are in it;
2) collisions.

Instead of linear array, judyarray classes
use a JudyL set of functions from Judy library (See url below).
JudyL implements a high-performance map from an integer type to a pointer type
(actually a map from Word_t to Word_t which is capable
for storing both int and void *).
Thus we have:
1) some overhead for mapping a hash value to an element
   (JudyL is slower than 'pointer[index]');
2) hash value in a range [0..2^32-1] (the default on 32/64 platforms) and,
   as a result, (*very rare*) collisions;
3) dynamic resizing of hash table, i.e. memory is allocated (and freed)
   as soon as it is needed (or unneeded anymore).

In case of collisions judy_map_{l,m} and judy_set_{l,m} classes use
chaining technique to resolve the collision, i.e. external storage is
used for storing conflicting elements.  judy_{set,map}_l classes use
list, while judy_{set,map}_m use map (or set),
this is why judy_{set,map}_m classes require Less predicate in
addition to Equal.

CONFIGURING
================

Edit manually Makefile.config file for your preferences

MAKING
================

After editing Makefile.config you may want to test the library.
Run the following for this

'make test'

Note that some libraries should be properly installed
(and configured in Makefile.config) for this to work.

INSTALL
================

There is nothing to be built for installing
this library, only C++ headers files are installed by

'make install'

command

BENCHMARKING
================

Edit Makefile.bench and then run the following

'make bench'
